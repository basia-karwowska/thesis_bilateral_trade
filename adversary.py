import numpy as np

# Adversarial strategy at time t

def adversarial_strategy1(price_grid): # first buyer, second seller, n length of the price grid
    K=len(price_grid)
    valuations = np.zeros(price_grid.shape) # valuations initialization
    valuations[:, 0] = np.random.uniform(0, 1, K)
    valuations[:, 1] = np.random.uniform(0, 1, K)
    return valuations
    

def adversarial_strategy2(price_grid):
    # price grid numpy array
    """
    Adversarial strategy where the adversary pre-sets the sequences for all arms.
    The adversary tries to make things difficult by setting the seller's valuations higher
    and the buyer's valuations lower with higher likelihood.
    """
    K = len(price_grid)
    
    # Generate perturbations for buyer and seller valuations
    perturbation_b = np.random.uniform(-0.4, 0.1, K)
    perturbation_s = np.random.uniform(-0.1, 0.4, K)
    
    # Apply perturbations
    valuations = price_grid.copy() # valuations initialization
    valuations[:, 0] += perturbation_b
    valuations[:, 1] += perturbation_s
    
    # Clamp the values to be within [0, 1] in a single step
    valuations = np.clip(valuations, 0, 1)
    
    return valuations

# Adversarial sequence of rewards
# These rewards cannot be directly chosen by the adversary given the construction
# of our problem - it can be chosen by the adversary whether or not the profit
# gets realized in the case where the objective function is profit!

# predefined sequence of rewards by an adversary so they do not need to disclose
# valuations, valuations can stay internal, valuations are generated by an
# adversarial_strategy and corresponding deterministic sequence of rewards is 
# generated accordingly
def adversarial_rewards(price_grid, adversarial_strategy, T): # at time t, for all arms
    K = len(price_grid)
    rewards = np.zeros((T, K))
    for t in range(T):
        valuations = adversarial_strategy(price_grid)
        potential_profits = np.array([price_grid[i][0]-price_grid[i][1] for i in range(K)])
        trade_happened = (valuations[:, 0] > price_grid[:, 0]) & (valuations[:, 1] < price_grid[:, 1])
        rewards[t, :] = trade_happened * potential_profits
    return rewards
    
    
